// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: SMSProtocol.proto

#ifndef PROTOBUF_SMSProtocol_2eproto__INCLUDED
#define PROTOBUF_SMSProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace sms {
namespace protocol {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_SMSProtocol_2eproto();
void protobuf_AssignDesc_SMSProtocol_2eproto();
void protobuf_ShutdownFile_SMSProtocol_2eproto();

class ClientToBrokerMessage;
class BrokerToClientMessage;

enum ClientToBrokerMessage_ClientToBrokerMessageType {
  ClientToBrokerMessage_ClientToBrokerMessageType_CLIENT_SUBSCRIBE_TO_TOPIC = 0,
  ClientToBrokerMessage_ClientToBrokerMessageType_CLIENT_UNSUBSCRIBE_FROM_TOPIC = 1,
  ClientToBrokerMessage_ClientToBrokerMessageType_CLIENT_SEND_MESSAGE_TO_TOPIC = 2
};
bool ClientToBrokerMessage_ClientToBrokerMessageType_IsValid(int value);
const ClientToBrokerMessage_ClientToBrokerMessageType ClientToBrokerMessage_ClientToBrokerMessageType_ClientToBrokerMessageType_MIN = ClientToBrokerMessage_ClientToBrokerMessageType_CLIENT_SUBSCRIBE_TO_TOPIC;
const ClientToBrokerMessage_ClientToBrokerMessageType ClientToBrokerMessage_ClientToBrokerMessageType_ClientToBrokerMessageType_MAX = ClientToBrokerMessage_ClientToBrokerMessageType_CLIENT_SEND_MESSAGE_TO_TOPIC;
const int ClientToBrokerMessage_ClientToBrokerMessageType_ClientToBrokerMessageType_ARRAYSIZE = ClientToBrokerMessage_ClientToBrokerMessageType_ClientToBrokerMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClientToBrokerMessage_ClientToBrokerMessageType_descriptor();
inline const ::std::string& ClientToBrokerMessage_ClientToBrokerMessageType_Name(ClientToBrokerMessage_ClientToBrokerMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClientToBrokerMessage_ClientToBrokerMessageType_descriptor(), value);
}
inline bool ClientToBrokerMessage_ClientToBrokerMessageType_Parse(
    const ::std::string& name, ClientToBrokerMessage_ClientToBrokerMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClientToBrokerMessage_ClientToBrokerMessageType>(
    ClientToBrokerMessage_ClientToBrokerMessageType_descriptor(), name, value);
}
enum BrokerToClientMessage_BrokerToClientMessageType {
  BrokerToClientMessage_BrokerToClientMessageType_BROKER_TOPIC_MESSAGE_PUBLISH = 0
};
bool BrokerToClientMessage_BrokerToClientMessageType_IsValid(int value);
const BrokerToClientMessage_BrokerToClientMessageType BrokerToClientMessage_BrokerToClientMessageType_BrokerToClientMessageType_MIN = BrokerToClientMessage_BrokerToClientMessageType_BROKER_TOPIC_MESSAGE_PUBLISH;
const BrokerToClientMessage_BrokerToClientMessageType BrokerToClientMessage_BrokerToClientMessageType_BrokerToClientMessageType_MAX = BrokerToClientMessage_BrokerToClientMessageType_BROKER_TOPIC_MESSAGE_PUBLISH;
const int BrokerToClientMessage_BrokerToClientMessageType_BrokerToClientMessageType_ARRAYSIZE = BrokerToClientMessage_BrokerToClientMessageType_BrokerToClientMessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BrokerToClientMessage_BrokerToClientMessageType_descriptor();
inline const ::std::string& BrokerToClientMessage_BrokerToClientMessageType_Name(BrokerToClientMessage_BrokerToClientMessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BrokerToClientMessage_BrokerToClientMessageType_descriptor(), value);
}
inline bool BrokerToClientMessage_BrokerToClientMessageType_Parse(
    const ::std::string& name, BrokerToClientMessage_BrokerToClientMessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BrokerToClientMessage_BrokerToClientMessageType>(
    BrokerToClientMessage_BrokerToClientMessageType_descriptor(), name, value);
}
// ===================================================================

class ClientToBrokerMessage : public ::google::protobuf::Message {
 public:
  ClientToBrokerMessage();
  virtual ~ClientToBrokerMessage();

  ClientToBrokerMessage(const ClientToBrokerMessage& from);

  inline ClientToBrokerMessage& operator=(const ClientToBrokerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientToBrokerMessage& default_instance();

  void Swap(ClientToBrokerMessage* other);

  // implements Message ----------------------------------------------

  ClientToBrokerMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientToBrokerMessage& from);
  void MergeFrom(const ClientToBrokerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ClientToBrokerMessage_ClientToBrokerMessageType ClientToBrokerMessageType;
  static const ClientToBrokerMessageType CLIENT_SUBSCRIBE_TO_TOPIC = ClientToBrokerMessage_ClientToBrokerMessageType_CLIENT_SUBSCRIBE_TO_TOPIC;
  static const ClientToBrokerMessageType CLIENT_UNSUBSCRIBE_FROM_TOPIC = ClientToBrokerMessage_ClientToBrokerMessageType_CLIENT_UNSUBSCRIBE_FROM_TOPIC;
  static const ClientToBrokerMessageType CLIENT_SEND_MESSAGE_TO_TOPIC = ClientToBrokerMessage_ClientToBrokerMessageType_CLIENT_SEND_MESSAGE_TO_TOPIC;
  static inline bool ClientToBrokerMessageType_IsValid(int value) {
    return ClientToBrokerMessage_ClientToBrokerMessageType_IsValid(value);
  }
  static const ClientToBrokerMessageType ClientToBrokerMessageType_MIN =
    ClientToBrokerMessage_ClientToBrokerMessageType_ClientToBrokerMessageType_MIN;
  static const ClientToBrokerMessageType ClientToBrokerMessageType_MAX =
    ClientToBrokerMessage_ClientToBrokerMessageType_ClientToBrokerMessageType_MAX;
  static const int ClientToBrokerMessageType_ARRAYSIZE =
    ClientToBrokerMessage_ClientToBrokerMessageType_ClientToBrokerMessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ClientToBrokerMessageType_descriptor() {
    return ClientToBrokerMessage_ClientToBrokerMessageType_descriptor();
  }
  static inline const ::std::string& ClientToBrokerMessageType_Name(ClientToBrokerMessageType value) {
    return ClientToBrokerMessage_ClientToBrokerMessageType_Name(value);
  }
  static inline bool ClientToBrokerMessageType_Parse(const ::std::string& name,
      ClientToBrokerMessageType* value) {
    return ClientToBrokerMessage_ClientToBrokerMessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .sms.protocol.protobuf.ClientToBrokerMessage.ClientToBrokerMessageType messageType = 1;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  inline ::sms::protocol::protobuf::ClientToBrokerMessage_ClientToBrokerMessageType messagetype() const;
  inline void set_messagetype(::sms::protocol::protobuf::ClientToBrokerMessage_ClientToBrokerMessageType value);

  // required string topicName = 2;
  inline bool has_topicname() const;
  inline void clear_topicname();
  static const int kTopicNameFieldNumber = 2;
  inline const ::std::string& topicname() const;
  inline void set_topicname(const ::std::string& value);
  inline void set_topicname(const char* value);
  inline void set_topicname(const char* value, size_t size);
  inline ::std::string* mutable_topicname();
  inline ::std::string* release_topicname();
  inline void set_allocated_topicname(::std::string* topicname);

  // optional bytes messagePayload = 3;
  inline bool has_messagepayload() const;
  inline void clear_messagepayload();
  static const int kMessagePayloadFieldNumber = 3;
  inline const ::std::string& messagepayload() const;
  inline void set_messagepayload(const ::std::string& value);
  inline void set_messagepayload(const char* value);
  inline void set_messagepayload(const void* value, size_t size);
  inline ::std::string* mutable_messagepayload();
  inline ::std::string* release_messagepayload();
  inline void set_allocated_messagepayload(::std::string* messagepayload);

  // @@protoc_insertion_point(class_scope:sms.protocol.protobuf.ClientToBrokerMessage)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_topicname();
  inline void clear_has_topicname();
  inline void set_has_messagepayload();
  inline void clear_has_messagepayload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* topicname_;
  ::std::string* messagepayload_;
  int messagetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SMSProtocol_2eproto();
  friend void protobuf_AssignDesc_SMSProtocol_2eproto();
  friend void protobuf_ShutdownFile_SMSProtocol_2eproto();

  void InitAsDefaultInstance();
  static ClientToBrokerMessage* default_instance_;
};
// -------------------------------------------------------------------

class BrokerToClientMessage : public ::google::protobuf::Message {
 public:
  BrokerToClientMessage();
  virtual ~BrokerToClientMessage();

  BrokerToClientMessage(const BrokerToClientMessage& from);

  inline BrokerToClientMessage& operator=(const BrokerToClientMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BrokerToClientMessage& default_instance();

  void Swap(BrokerToClientMessage* other);

  // implements Message ----------------------------------------------

  BrokerToClientMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BrokerToClientMessage& from);
  void MergeFrom(const BrokerToClientMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BrokerToClientMessage_BrokerToClientMessageType BrokerToClientMessageType;
  static const BrokerToClientMessageType BROKER_TOPIC_MESSAGE_PUBLISH = BrokerToClientMessage_BrokerToClientMessageType_BROKER_TOPIC_MESSAGE_PUBLISH;
  static inline bool BrokerToClientMessageType_IsValid(int value) {
    return BrokerToClientMessage_BrokerToClientMessageType_IsValid(value);
  }
  static const BrokerToClientMessageType BrokerToClientMessageType_MIN =
    BrokerToClientMessage_BrokerToClientMessageType_BrokerToClientMessageType_MIN;
  static const BrokerToClientMessageType BrokerToClientMessageType_MAX =
    BrokerToClientMessage_BrokerToClientMessageType_BrokerToClientMessageType_MAX;
  static const int BrokerToClientMessageType_ARRAYSIZE =
    BrokerToClientMessage_BrokerToClientMessageType_BrokerToClientMessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BrokerToClientMessageType_descriptor() {
    return BrokerToClientMessage_BrokerToClientMessageType_descriptor();
  }
  static inline const ::std::string& BrokerToClientMessageType_Name(BrokerToClientMessageType value) {
    return BrokerToClientMessage_BrokerToClientMessageType_Name(value);
  }
  static inline bool BrokerToClientMessageType_Parse(const ::std::string& name,
      BrokerToClientMessageType* value) {
    return BrokerToClientMessage_BrokerToClientMessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .sms.protocol.protobuf.BrokerToClientMessage.BrokerToClientMessageType messageType = 1;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  inline ::sms::protocol::protobuf::BrokerToClientMessage_BrokerToClientMessageType messagetype() const;
  inline void set_messagetype(::sms::protocol::protobuf::BrokerToClientMessage_BrokerToClientMessageType value);

  // required string topicName = 2;
  inline bool has_topicname() const;
  inline void clear_topicname();
  static const int kTopicNameFieldNumber = 2;
  inline const ::std::string& topicname() const;
  inline void set_topicname(const ::std::string& value);
  inline void set_topicname(const char* value);
  inline void set_topicname(const char* value, size_t size);
  inline ::std::string* mutable_topicname();
  inline ::std::string* release_topicname();
  inline void set_allocated_topicname(::std::string* topicname);

  // optional bytes messagePayload = 3;
  inline bool has_messagepayload() const;
  inline void clear_messagepayload();
  static const int kMessagePayloadFieldNumber = 3;
  inline const ::std::string& messagepayload() const;
  inline void set_messagepayload(const ::std::string& value);
  inline void set_messagepayload(const char* value);
  inline void set_messagepayload(const void* value, size_t size);
  inline ::std::string* mutable_messagepayload();
  inline ::std::string* release_messagepayload();
  inline void set_allocated_messagepayload(::std::string* messagepayload);

  // @@protoc_insertion_point(class_scope:sms.protocol.protobuf.BrokerToClientMessage)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_topicname();
  inline void clear_has_topicname();
  inline void set_has_messagepayload();
  inline void clear_has_messagepayload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* topicname_;
  ::std::string* messagepayload_;
  int messagetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_SMSProtocol_2eproto();
  friend void protobuf_AssignDesc_SMSProtocol_2eproto();
  friend void protobuf_ShutdownFile_SMSProtocol_2eproto();

  void InitAsDefaultInstance();
  static BrokerToClientMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientToBrokerMessage

// required .sms.protocol.protobuf.ClientToBrokerMessage.ClientToBrokerMessageType messageType = 1;
inline bool ClientToBrokerMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToBrokerMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToBrokerMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToBrokerMessage::clear_messagetype() {
  messagetype_ = 0;
  clear_has_messagetype();
}
inline ::sms::protocol::protobuf::ClientToBrokerMessage_ClientToBrokerMessageType ClientToBrokerMessage::messagetype() const {
  return static_cast< ::sms::protocol::protobuf::ClientToBrokerMessage_ClientToBrokerMessageType >(messagetype_);
}
inline void ClientToBrokerMessage::set_messagetype(::sms::protocol::protobuf::ClientToBrokerMessage_ClientToBrokerMessageType value) {
  assert(::sms::protocol::protobuf::ClientToBrokerMessage_ClientToBrokerMessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
}

// required string topicName = 2;
inline bool ClientToBrokerMessage::has_topicname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientToBrokerMessage::set_has_topicname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientToBrokerMessage::clear_has_topicname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientToBrokerMessage::clear_topicname() {
  if (topicname_ != &::google::protobuf::internal::kEmptyString) {
    topicname_->clear();
  }
  clear_has_topicname();
}
inline const ::std::string& ClientToBrokerMessage::topicname() const {
  return *topicname_;
}
inline void ClientToBrokerMessage::set_topicname(const ::std::string& value) {
  set_has_topicname();
  if (topicname_ == &::google::protobuf::internal::kEmptyString) {
    topicname_ = new ::std::string;
  }
  topicname_->assign(value);
}
inline void ClientToBrokerMessage::set_topicname(const char* value) {
  set_has_topicname();
  if (topicname_ == &::google::protobuf::internal::kEmptyString) {
    topicname_ = new ::std::string;
  }
  topicname_->assign(value);
}
inline void ClientToBrokerMessage::set_topicname(const char* value, size_t size) {
  set_has_topicname();
  if (topicname_ == &::google::protobuf::internal::kEmptyString) {
    topicname_ = new ::std::string;
  }
  topicname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToBrokerMessage::mutable_topicname() {
  set_has_topicname();
  if (topicname_ == &::google::protobuf::internal::kEmptyString) {
    topicname_ = new ::std::string;
  }
  return topicname_;
}
inline ::std::string* ClientToBrokerMessage::release_topicname() {
  clear_has_topicname();
  if (topicname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = topicname_;
    topicname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToBrokerMessage::set_allocated_topicname(::std::string* topicname) {
  if (topicname_ != &::google::protobuf::internal::kEmptyString) {
    delete topicname_;
  }
  if (topicname) {
    set_has_topicname();
    topicname_ = topicname;
  } else {
    clear_has_topicname();
    topicname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes messagePayload = 3;
inline bool ClientToBrokerMessage::has_messagepayload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientToBrokerMessage::set_has_messagepayload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientToBrokerMessage::clear_has_messagepayload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientToBrokerMessage::clear_messagepayload() {
  if (messagepayload_ != &::google::protobuf::internal::kEmptyString) {
    messagepayload_->clear();
  }
  clear_has_messagepayload();
}
inline const ::std::string& ClientToBrokerMessage::messagepayload() const {
  return *messagepayload_;
}
inline void ClientToBrokerMessage::set_messagepayload(const ::std::string& value) {
  set_has_messagepayload();
  if (messagepayload_ == &::google::protobuf::internal::kEmptyString) {
    messagepayload_ = new ::std::string;
  }
  messagepayload_->assign(value);
}
inline void ClientToBrokerMessage::set_messagepayload(const char* value) {
  set_has_messagepayload();
  if (messagepayload_ == &::google::protobuf::internal::kEmptyString) {
    messagepayload_ = new ::std::string;
  }
  messagepayload_->assign(value);
}
inline void ClientToBrokerMessage::set_messagepayload(const void* value, size_t size) {
  set_has_messagepayload();
  if (messagepayload_ == &::google::protobuf::internal::kEmptyString) {
    messagepayload_ = new ::std::string;
  }
  messagepayload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToBrokerMessage::mutable_messagepayload() {
  set_has_messagepayload();
  if (messagepayload_ == &::google::protobuf::internal::kEmptyString) {
    messagepayload_ = new ::std::string;
  }
  return messagepayload_;
}
inline ::std::string* ClientToBrokerMessage::release_messagepayload() {
  clear_has_messagepayload();
  if (messagepayload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messagepayload_;
    messagepayload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientToBrokerMessage::set_allocated_messagepayload(::std::string* messagepayload) {
  if (messagepayload_ != &::google::protobuf::internal::kEmptyString) {
    delete messagepayload_;
  }
  if (messagepayload) {
    set_has_messagepayload();
    messagepayload_ = messagepayload;
  } else {
    clear_has_messagepayload();
    messagepayload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BrokerToClientMessage

// required .sms.protocol.protobuf.BrokerToClientMessage.BrokerToClientMessageType messageType = 1;
inline bool BrokerToClientMessage::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrokerToClientMessage::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrokerToClientMessage::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrokerToClientMessage::clear_messagetype() {
  messagetype_ = 0;
  clear_has_messagetype();
}
inline ::sms::protocol::protobuf::BrokerToClientMessage_BrokerToClientMessageType BrokerToClientMessage::messagetype() const {
  return static_cast< ::sms::protocol::protobuf::BrokerToClientMessage_BrokerToClientMessageType >(messagetype_);
}
inline void BrokerToClientMessage::set_messagetype(::sms::protocol::protobuf::BrokerToClientMessage_BrokerToClientMessageType value) {
  assert(::sms::protocol::protobuf::BrokerToClientMessage_BrokerToClientMessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
}

// required string topicName = 2;
inline bool BrokerToClientMessage::has_topicname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BrokerToClientMessage::set_has_topicname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BrokerToClientMessage::clear_has_topicname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BrokerToClientMessage::clear_topicname() {
  if (topicname_ != &::google::protobuf::internal::kEmptyString) {
    topicname_->clear();
  }
  clear_has_topicname();
}
inline const ::std::string& BrokerToClientMessage::topicname() const {
  return *topicname_;
}
inline void BrokerToClientMessage::set_topicname(const ::std::string& value) {
  set_has_topicname();
  if (topicname_ == &::google::protobuf::internal::kEmptyString) {
    topicname_ = new ::std::string;
  }
  topicname_->assign(value);
}
inline void BrokerToClientMessage::set_topicname(const char* value) {
  set_has_topicname();
  if (topicname_ == &::google::protobuf::internal::kEmptyString) {
    topicname_ = new ::std::string;
  }
  topicname_->assign(value);
}
inline void BrokerToClientMessage::set_topicname(const char* value, size_t size) {
  set_has_topicname();
  if (topicname_ == &::google::protobuf::internal::kEmptyString) {
    topicname_ = new ::std::string;
  }
  topicname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BrokerToClientMessage::mutable_topicname() {
  set_has_topicname();
  if (topicname_ == &::google::protobuf::internal::kEmptyString) {
    topicname_ = new ::std::string;
  }
  return topicname_;
}
inline ::std::string* BrokerToClientMessage::release_topicname() {
  clear_has_topicname();
  if (topicname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = topicname_;
    topicname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BrokerToClientMessage::set_allocated_topicname(::std::string* topicname) {
  if (topicname_ != &::google::protobuf::internal::kEmptyString) {
    delete topicname_;
  }
  if (topicname) {
    set_has_topicname();
    topicname_ = topicname;
  } else {
    clear_has_topicname();
    topicname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes messagePayload = 3;
inline bool BrokerToClientMessage::has_messagepayload() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BrokerToClientMessage::set_has_messagepayload() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BrokerToClientMessage::clear_has_messagepayload() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BrokerToClientMessage::clear_messagepayload() {
  if (messagepayload_ != &::google::protobuf::internal::kEmptyString) {
    messagepayload_->clear();
  }
  clear_has_messagepayload();
}
inline const ::std::string& BrokerToClientMessage::messagepayload() const {
  return *messagepayload_;
}
inline void BrokerToClientMessage::set_messagepayload(const ::std::string& value) {
  set_has_messagepayload();
  if (messagepayload_ == &::google::protobuf::internal::kEmptyString) {
    messagepayload_ = new ::std::string;
  }
  messagepayload_->assign(value);
}
inline void BrokerToClientMessage::set_messagepayload(const char* value) {
  set_has_messagepayload();
  if (messagepayload_ == &::google::protobuf::internal::kEmptyString) {
    messagepayload_ = new ::std::string;
  }
  messagepayload_->assign(value);
}
inline void BrokerToClientMessage::set_messagepayload(const void* value, size_t size) {
  set_has_messagepayload();
  if (messagepayload_ == &::google::protobuf::internal::kEmptyString) {
    messagepayload_ = new ::std::string;
  }
  messagepayload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BrokerToClientMessage::mutable_messagepayload() {
  set_has_messagepayload();
  if (messagepayload_ == &::google::protobuf::internal::kEmptyString) {
    messagepayload_ = new ::std::string;
  }
  return messagepayload_;
}
inline ::std::string* BrokerToClientMessage::release_messagepayload() {
  clear_has_messagepayload();
  if (messagepayload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messagepayload_;
    messagepayload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BrokerToClientMessage::set_allocated_messagepayload(::std::string* messagepayload) {
  if (messagepayload_ != &::google::protobuf::internal::kEmptyString) {
    delete messagepayload_;
  }
  if (messagepayload) {
    set_has_messagepayload();
    messagepayload_ = messagepayload;
  } else {
    clear_has_messagepayload();
    messagepayload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace protocol
}  // namespace sms

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sms::protocol::protobuf::ClientToBrokerMessage_ClientToBrokerMessageType>() {
  return ::sms::protocol::protobuf::ClientToBrokerMessage_ClientToBrokerMessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sms::protocol::protobuf::BrokerToClientMessage_BrokerToClientMessageType>() {
  return ::sms::protocol::protobuf::BrokerToClientMessage_BrokerToClientMessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_SMSProtocol_2eproto__INCLUDED
